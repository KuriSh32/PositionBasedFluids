#version 430 core

layout(local_size_x = 256) in;

layout(binding = 0, r32f) uniform readonly image2D inputDepthTexture;
layout(binding = 1, r32f) uniform writeonly image2D outputDepthTexture;
layout(binding = 2, r8i) uniform readonly iimage2D fragSampledFlagTexture;

uniform int SCR_WIDTH;
uniform int SCR_HEIGHT;

const int KERNEL_SIZE = 3;

// const float GAUSSIAN_WEIGHTS[KERNEL_SIZE] = float[] (0.197448, 0.174697, 0.120999, 0.065602, 0.02784, 0.009246, 0.002403, 0.000489);

const float BILATERAL_PARA_sigma_d = 1.0;
const float BILATERAL_PARA_sigma_r = 1.0;

void main() {
    uint index = gl_GlobalInvocationID.x;
    ivec2 texelCoord = ivec2(index % SCR_WIDTH, index / SCR_WIDTH);
    // ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    if (texelCoord.x >= SCR_WIDTH || texelCoord.y >= SCR_HEIGHT) {
        return;
    }

    int valid = imageLoad(fragSampledFlagTexture, texelCoord).r;
    if (valid == 0) {
        return;
    }

    // Gaussian blur
    // float aDepth = imageLoad(inputDepthTexture, texelCoord).r * GAUSSIAN_WEIGHTS[0];
    // for (int i = 1; i < KERNEL_SIZE; i++) {
    //     aDepth += imageLoad(inputDepthTexture, texelCoord + ivec2(i, 0)).r * GAUSSIAN_WEIGHTS[i];
    //     aDepth += imageLoad(inputDepthTexture, texelCoord + ivec2(-i, 0)).r * GAUSSIAN_WEIGHTS[i];
    // }

    // Bilateral blur
    // float w_p = 0.0;
    // float sum = 0.0;
    // float aDepth = imageLoad(inputDepthTexture, texelCoord).r;
    // float rDenominatorInverse = 1.0 / (2.0 * BILATERAL_PARA_sigma_r * BILATERAL_PARA_sigma_r);
    // float dDenominatorInverse = 1.0 / (2.0 * BILATERAL_PARA_sigma_d * BILATERAL_PARA_sigma_d);
    // for (int i = -KERNEL_SIZE; i <= KERNEL_SIZE; i++) {
    //     for (int j = -KERNEL_SIZE; j <= KERNEL_SIZE; j++) {
    //         int x = texelCoord.x + i;
    //         int y = texelCoord.y + j;

    //         vec2 d_xy = vec2(i, j);
    //         float f_d = exp(-dot(d_xy, d_xy) * dDenominatorInverse);

    //         float depth = imageLoad(inputDepthTexture, ivec2(x, y)).r;
    //         float d_depth = depth - aDepth;
    //         float f_r = exp(-d_depth * d_depth * rDenominatorInverse);

    //         w_p += f_r * f_d;
    //         sum += depth * f_r * f_d;
    //     }
    // }
    // if (w_p == 0.0) {
    //     aDepth = aDepth;
    // } else {
    //     aDepth = sum / w_p;
    // }

    // Two-step bilateral blur
    float w_p = 0.0;
    float sum = 0.0;
    float aDepth = imageLoad(inputDepthTexture, texelCoord).r;
    float rDenominatorInverse = 1.0 / (2.0 * BILATERAL_PARA_sigma_r * BILATERAL_PARA_sigma_r);
    float dDenominatorInverse = 1.0 / (2.0 * BILATERAL_PARA_sigma_d * BILATERAL_PARA_sigma_d);
    for (int i = -KERNEL_SIZE; i <= KERNEL_SIZE; i++) {
        int x = texelCoord.x + i;
        int y = texelCoord.y;

        vec2 d_xy = vec2(i, 0);
        float f_d = exp(-dot(d_xy, d_xy) * dDenominatorInverse);

        float depth = imageLoad(inputDepthTexture, ivec2(x, y)).r;
        int flag = imageLoad(fragSampledFlagTexture, ivec2(x, y)).r;
        float d_depth = depth - aDepth;
        float f_r = exp(-d_depth * d_depth * rDenominatorInverse);

        if (flag == 1) {
            w_p += f_r * f_d;
            sum += depth * f_r * f_d;
        }
    }
    if (w_p == 0.0) {
        aDepth = aDepth;
    } else {
        aDepth = sum / w_p;
    }

    imageStore(outputDepthTexture, texelCoord, vec4(aDepth, 0.0, 0.0, 0.0));
}